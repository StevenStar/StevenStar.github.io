<!DOCTYPE html>






  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



















  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Source Sans Pro,Calibri,Candara,Arial,sans-serif:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="http://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="一、HTML 面试问题及答案HTML 基础 说说你对语义化的理解？ 1234去掉或者丢失样式的时候能够让页面呈现出清晰的结构有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队">
<meta name="keywords" content="前端,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试集锦">
<meta property="og:url" content="http://stevenstar.github.io/web/web_topic_01/index.html">
<meta property="og:site_name" content="王俊星的博客">
<meta property="og:description" content="一、HTML 面试问题及答案HTML 基础 说说你对语义化的理解？ 1234去掉或者丢失样式的时候能够让页面呈现出清晰的结构有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-02-18T09:29:58.870Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试集锦">
<meta name="twitter:description" content="一、HTML 面试问题及答案HTML 基础 说说你对语义化的理解？ 1234去掉或者丢失样式的时候能够让页面呈现出清晰的结构有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队">






  <link rel="canonical" href="http://stevenstar.github.io/web/web_topic_01/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>前端面试集锦 | 王俊星的博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">王俊星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">为了生活编程，编程改变生活</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">
    <a href="/sitemap.xml" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />站点地图</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">
    <a href="/404.html" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />公益 404</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenstar.github.io/web/web_topic_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/4902693">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王俊星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端面试集锦
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-10 16:14:28" itemprop="dateCreated datePublished" datetime="2018-05-10T16:14:28+08:00">2018-05-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-18 17:29:58" itemprop="dateModified" datetime="2019-02-18T17:29:58+08:00">2019-02-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/web/web_topic_01/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="web/web_topic_01/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一、HTML-面试问题及答案"><a href="#一、HTML-面试问题及答案" class="headerlink" title="一、HTML 面试问题及答案"></a>一、HTML 面试问题及答案</h1><h2 id="HTML-基础"><a href="#HTML-基础" class="headerlink" title="HTML 基础"></a>HTML 基础</h2><ol>
<li><p>说说你对语义化的理解？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">去掉或者丢失样式的时候能够让页面呈现出清晰的结构</span><br><span class="line">有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</span><br><span class="line">方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</span><br><span class="line">便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义??</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt;声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器以何种模式来渲染文档。</span><br><span class="line">严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。</span><br><span class="line">在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</span><br><span class="line">DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="二、CSS-面试问题及答案"><a href="#二、CSS-面试问题及答案" class="headerlink" title="二、CSS 面试问题及答案"></a>二、CSS 面试问题及答案</h1><h2 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h2><ol>
<li><p>css盒子模型?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">页面渲染时，dom元素所采用的布局模型。可通过box-sizing进行设置。根据计算宽高的区域可分为：</span><br><span class="line">1. content-box (W3C标准盒模型)</span><br><span class="line">2. border-box (IE 盒子模型) IE的content部分包含了 border 和 pading;</span><br><span class="line">3. padding-box</span><br><span class="line">4. margin-box</span><br></pre></td></tr></table></figure>
</li>
<li><p>BFC?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">块级格式化上下文，是一个独立的渲染区域，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</span><br><span class="line">IE下为Layout，可通过zoom:1; 触发</span><br><span class="line">触发条件：</span><br><span class="line">1. 跟元素</span><br><span class="line">2. position: absolute/fixed</span><br><span class="line">3. float 元素</span><br><span class="line">4. overflow != visible</span><br><span class="line">规则：</span><br><span class="line">1. 属于同一个BFC的两个相邻Box垂直排列</span><br><span class="line">2. 属于同一个BFC的两个相邻Box的margin会发生重叠</span><br><span class="line">3. BFC中子元素的margin box的左边，与包含块（BFC）border box的左边相接触（子元素absolute除外）</span><br><span class="line">4. BFC的区域不会与float的元素区域重叠</span><br><span class="line">5. 计算BFC的高度时，浮动子元素也参与计算</span><br><span class="line">6. 文字层不会被浮动层覆盖，环绕于周围</span><br><span class="line">应用：</span><br><span class="line">1. 阻止margin重叠</span><br><span class="line">2. 可以包含浮动元素 -- 清除内部浮动（清除浮动的原理是两个div都位于同一个BFC区域之中）</span><br><span class="line">3. 自适用两栏布局</span><br><span class="line">4. 可以阻止元素被浮动元素覆盖</span><br></pre></td></tr></table></figure>
</li>
<li><p>.css选择符有哪些？优先级算法如何计算?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ID选择器</span><br><span class="line">类选择器</span><br><span class="line">标签选择器</span><br><span class="line">相邻选择器</span><br><span class="line">子选择器</span><br><span class="line">后代选择器</span><br><span class="line">通配符选择器</span><br><span class="line">属性选择器</span><br><span class="line">伪类选择器</span><br><span class="line">可继承的样式</span><br><span class="line">不可继承的样式</span><br><span class="line"></span><br><span class="line">优先级就近原则，同权重情况下样式定义最近者为准;</span><br><span class="line">!import &gt; 行内样式 &gt; #id &gt; .class &gt; tag &gt; * &gt; 继承 &gt; 默认</span><br></pre></td></tr></table></figure>
</li>
<li><p>层叠上下文？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">元素提升为一个比较特殊的图层，在三维空间中（z轴）高出普通元素一等。</span><br><span class="line">触发条件：</span><br><span class="line">1. 根层叠上下文(html)</span><br><span class="line">2. position</span><br><span class="line">3. css3属性</span><br><span class="line">    flex</span><br><span class="line">    transform</span><br><span class="line">    opacity</span><br><span class="line">    filter</span><br><span class="line">    will-change</span><br><span class="line">    -webkit-overflow-scrolling</span><br><span class="line">4. 层叠等级</span><br><span class="line">    在同一层叠上下文中，层叠等级才有意义</span><br><span class="line">    z-index的优先级最高</span><br><span class="line">background/border &gt; z-index为负值 &gt; 块级元素 &gt; 浮动元素 &gt; 行内元素 &gt; z-index: 0/auto &gt; z-index为正值</span><br></pre></td></tr></table></figure>
</li>
<li><p>居中布局？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 水平居中</span><br><span class="line">    行内元素：text-align: center;</span><br><span class="line">    块级元素：margin: 0 auto;</span><br><span class="line">    absolute + transform</span><br><span class="line">    flex + justify-content: center;</span><br><span class="line">2. 垂直居中</span><br><span class="line">    line-height: height;</span><br><span class="line">    absolute + transform</span><br><span class="line">    flex + align-items: center;</span><br><span class="line">    table</span><br><span class="line">3. 水平垂直居中</span><br><span class="line">    absolute + transoform;</span><br><span class="line">    flex + justify-content + align-items;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去除浮动影戏那个，防止父级高度塌陷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过增加尾部清除浮动: :after/&lt;br&gt; : clear: both;</span><br><span class="line">创建父级BFC</span><br><span class="line">父级设置高度</span><br></pre></td></tr></table></figure>
</li>
<li><p>link 与@import的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">link功能比较多，可以定义rss，定义Rel等作用，而@import 只能用于加载css</span><br><span class="line">当解析到link时，页面会同步加载所引的css，而@import所引用的css会等到页面加载完才被加载</span><br><span class="line">@import需要IE5以上才能使用</span><br><span class="line">link可以使用js动态引入，@import不行</span><br></pre></td></tr></table></figure>
</li>
<li><p>css预处理器(sass/less/postcss)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">css预处理的原理：是将类css更多更强大的功能，常用功能：嵌套，变量，循环语句，条件语句，自动前缀，单位转换，mixin复用</span><br></pre></td></tr></table></figure>
</li>
<li><p>css 动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">transition: 过渡动画</span><br><span class="line">    transition-property: 属性</span><br><span class="line">    transition-duration: 间隔</span><br><span class="line">    transition-timing-function: 曲线</span><br><span class="line">    transition-delay: 延迟</span><br><span class="line">    常用钩子：transitionend</span><br><span class="line">animation/keyframes</span><br><span class="line">    animation-name: 动画名称，对应@keyframes</span><br><span class="line">    animation-duration: 间隔</span><br><span class="line">    animation-timing-function: 曲线</span><br><span class="line">    animation-delay: 延迟</span><br><span class="line">    animation-iteration-count: 次数</span><br><span class="line">        infinite: 循环动画</span><br><span class="line">    animation-direction: 方向</span><br><span class="line">        alternate: 反向播放</span><br><span class="line">    animation-fill-mode: 静止模式</span><br><span class="line">        forwards: 停止时，保留最后一帧</span><br><span class="line">        backwards: 停止时，回到第一帧</span><br><span class="line">        both: 同时运用forwards/backwards</span><br><span class="line">    常用钩子：animationend</span><br><span class="line">动画属性：尽量使用动画属性进行动画，能拥有较好的性能表现</span><br><span class="line">    translate</span><br><span class="line">    scale</span><br><span class="line">    rotate</span><br><span class="line">    skew</span><br><span class="line">    opacity</span><br><span class="line">    color</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="三、JAVASCRIPT-面试问题及答案"><a href="#三、JAVASCRIPT-面试问题及答案" class="headerlink" title="三、JAVASCRIPT 面试问题及答案"></a>三、JAVASCRIPT 面试问题及答案</h1><h2 id="JS-基础"><a href="#JS-基础" class="headerlink" title="JS 基础"></a>JS 基础</h2><ol>
<li><p>介绍一下JS的数据类型？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">简单类型：String、Number、Boolean、Null、Undefined</span><br><span class="line">复杂类型：Object</span><br><span class="line"></span><br><span class="line">&amp;扩展：</span><br><span class="line">  1. null与undefined有什么区别？</span><br><span class="line">     null 表示一个对象被定义了，值为“空值”，而undefined 表示不存在这个值。所以使用typeof判断是，null返回的是object，而undefined返回的是undefind</span><br><span class="line">  2. Boolean类型在进行判断的时候设置为 0、-0、null、&quot;&quot;、false、undefined 或 NaN，则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 &quot;false&quot;）</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何通过JS判断一个数组？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">instanceof方法</span><br><span class="line">    instanceof 运算符是用来测试一个对象是否在其原型链原型构造函数的属性。</span><br><span class="line">    var arr = [];</span><br><span class="line">    arr instanceof Array; // true</span><br><span class="line"></span><br><span class="line">constructor方法</span><br><span class="line">    constructor 属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数。</span><br><span class="line">    var arr = [];</span><br><span class="line">    arr.constructor == Array; //true</span><br><span class="line"></span><br><span class="line">特性判断法</span><br><span class="line">    利用判断数组独有的length和splice方法，但是这是不靠谱的，因为对象也能添加方法和属性。那怎么办了，有一个办法，可以利用数组的length属性没法枚举来判断。</span><br><span class="line">    function isArray(object)&#123;</span><br><span class="line">    	//判断length属性是否是可枚举的 对于数组 将得到false</span><br><span class="line">    	return  object &amp;&amp; typeof object===&apos;object&apos; &amp;&amp; typeof object.length===&apos;number&apos; &amp;&amp; typeof object.splice===&apos;function&apos; &amp;&amp; !(object.propertyIsEnumerable(&apos;length&apos;));</span><br><span class="line"></span><br><span class="line">最简单的方法</span><br><span class="line">    这种写法，是 jQuery 正在使用的，淘宝的 kissy 也是使用这种方式。</span><br><span class="line">    Object.prototype.toString.call(value) == &apos;[object Array]&apos;</span><br><span class="line">    // 利用这个方法，可以写一个返回数据类型的方法</span><br><span class="line">    var isType = function (obj) &#123;</span><br><span class="line">    	return Object.prototype.toString.call(obj).slice(8,-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">ES5新增方法isArray()</span><br><span class="line">    var a = new Array(123);</span><br><span class="line">    var b = new Date();</span><br><span class="line">    console.log(Array.isArray(a)); //true</span><br><span class="line">    console.log(Array.isArray(b)); //false</span><br><span class="line"></span><br><span class="line">&amp;扩展</span><br><span class="line">    使用instaceof和construcor，被判断的array必须是在当前页面声明的。比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false。</span><br><span class="line">    最简单的方法，在IE6下判断null和undefined，有一些bug，判断undefined和null均为Object，(并不是bug，是在ES3的标准下返回的就为Object)</span><br></pre></td></tr></table></figure>
</li>
<li><p>谈一谈let与var的区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let为ES6新添加申明变量的命令，它类似于var，但是有以下不同：</span><br><span class="line">    let命令不存在变量提升，如果在let前使用，会导致报错</span><br><span class="line">    暂时性死区，如果块区中存在let和const命令，就会形成封闭作用域</span><br><span class="line">    不允许重复声明，因此，不能在函数内部重新声明参数</span><br></pre></td></tr></table></figure>
</li>
<li><p>map与forEach的区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">因为平时基本只用forEach，所以这个很尴尬，索性就把新增的数组方法都刷一遍吧。</span><br><span class="line">    forEach方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容item、数组索引index、和当前遍历数组Array。另外，除去第一个必须的回调函数参数，还可以接受一个上下文参数(改变回调函数的this指向)；并且forEach不会遍历空元素。</span><br><span class="line">    map方法，基本用法与forEach一致，但是不同的，它会返回一个新的数组，所以在callback需要有return值，如果没有，会返回undefined。(从字面理解，map就是映射的意思)</span><br><span class="line">    filter方法，用法和map很相似，从字面理解，就是过滤、筛选的意思。但是函数的callback需要返回布尔值true或false，并且返回值只需要为弱等==即可。</span><br><span class="line">    some 方法，对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true。(一旦遇到true，就会中断循环，返回true，类似于||判断)</span><br><span class="line">    every方法，对数组中的每一项运行给定函数，如果该函数对每一项返回true，则返回true。(一旦遇到false，就会中断循环，返回false，类似于&amp;&amp;判断)</span><br><span class="line">    indexOf方法，与字符串中的indexOf类似，返回数组索引值，如果没有匹配，则会返回-1，第二个参数为可选，表示从当前位置开始搜索。</span><br><span class="line">    lastIndexOf方法，与indexOf相似，只是是从数组的末尾开始查找，而第二个参数的默认值是array.length - 1。</span><br><span class="line">    reduce方法，字面意思应该是‘减少’，但是实际是‘递归’的意思。实际就是应用一个函数针对数组的两个值(从左到右)，以减至一个值。它的callback接收4个参数：之前值(上一次循环返回的值)、当前值、索引值以及数组本身。initialValue参数可选，表示初始值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>谈一谈你理解的函数式编程？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。</span><br><span class="line">它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是&quot;第一等公民&quot;、只用&quot;表达式&quot;，不用&quot;语句&quot;(都会有返回值)、没有&quot;副作用&quot;、不修改状态、引用透明性。</span><br><span class="line">具体的特性代表了什么，还要好好研究一下！！</span><br></pre></td></tr></table></figure>
</li>
<li><p>谈一谈箭头函数与普通函数的区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">箭头函数使得表达更加简洁。(这个是废话)</span><br><span class="line">函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</span><br><span class="line">不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</span><br><span class="line">不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</span><br><span class="line">不可以使用yield命令，因此箭头函数不能用作Generator函数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>谈一谈函数中this的指向吧？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。</span><br><span class="line">《javascript语言精髓》中大概概括了4种调用方式：</span><br><span class="line">    方法调用模式</span><br><span class="line">    函数调用模式</span><br><span class="line">    构造器调用模式</span><br><span class="line">    apply/call调用模式</span><br><span class="line">特别补充：</span><br><span class="line">    在构造器调用时，如果加入了return并且return了一个对象，this会指向这个return的对象。</span><br><span class="line">    为什么构造器时this会指向new的对象？</span><br><span class="line">    var p = new Emp();</span><br><span class="line">    // 过程模拟，new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。</span><br><span class="line">    var p = &#123;&#125;;</span><br><span class="line">    Emp.apply(p);</span><br><span class="line">    p.__proto__=Emp.prototype;</span><br></pre></td></tr></table></figure>
</li>
<li><p>谈一谈闭包吧？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">「闭包」，是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。特性：</span><br><span class="line">    函数嵌套函数</span><br><span class="line">    函数内部可以引用外部的参数和变量</span><br><span class="line">    参数和变量不会被垃圾回收机制回收</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步编程的实现方式？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">回调函数：</span><br><span class="line">    优点：简单、容易理解</span><br><span class="line">    缺点：不利于维护，代码耦合高</span><br><span class="line">事件监听(采用时间驱动模式，取决于某个事件是否发生)：</span><br><span class="line">    优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</span><br><span class="line">    缺点：事件驱动型，流程不够清晰</span><br><span class="line">发布/订阅(观察者模式)：</span><br><span class="line">    类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者。</span><br><span class="line">Promise对象</span><br><span class="line">    优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；</span><br><span class="line">    缺点：编写和理解，相对比较难</span><br><span class="line">Generator函数</span><br><span class="line">    优点：函数体内外的数据交换、错误处理机制</span><br><span class="line">    缺点：流程管理不方便</span><br><span class="line">async函数</span><br><span class="line">    优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。</span><br><span class="line">    缺点：错误处理机制</span><br></pre></td></tr></table></figure>
</li>
<li><p>function P(){}<br>P.prototype.a = ‘a’;<br>function C(){}<br>C.prototype = new P();<br>var obj1 = new C();<br>通过obj1来进行修改a</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">    obj1._prototype_.a = &apos;xx&apos;;</span><br><span class="line">方法二：</span><br><span class="line">    obj1.constructor.prototype.a = &apos;xx&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>说一下图片的格式 jpg、png、gif</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">png8以及png24</span><br><span class="line">png8：8位索引色，1位透明通道</span><br><span class="line">png24：24位索引色，8位透明通道</span><br><span class="line">png图片设置半透明</span><br><span class="line">opacity，filter（滤镜）、png24本身是支持半透明的</span><br></pre></td></tr></table></figure>
</li>
<li><p>说说动画?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSS animation</span><br><span class="line">javascript操作（太频繁，经常reflow和repaint，面试官不满意）</span><br><span class="line">canvas画图</span><br></pre></td></tr></table></figure>
</li>
<li><p>谈一下你对ajax的认识?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">14. 请谈谈事件冒泡的过程?</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17. DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</span><br></pre></td></tr></table></figure>
<p>创建新节点:<br>    createDocumentFragment() // 创建一个DOM片段<br>    createElement() // 创建一个具体的元素<br>    createTextNode() // 创建一个文本节点<br>添加、移除、替换、插入:<br>    appendChild()<br>    removeChild()<br>    replaceChild()<br>    insertBefore() // 在已有的子节点前插入一个新的子节点<br>查找:<br>    getElementsByTagName() // 通过标签名称<br>    getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>    getElementById() // 通过元素Id，唯一性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 框架vue</span><br><span class="line">1. nextTick</span><br></pre></td></tr></table></figure></p>
<p>在下次dom更新循环结束之后执行延迟回调，可用于获取更新后的dom状态<br>    新版本中默认是mincrotasks, v-on中会使用macrotasks<br>    macrotasks任务的实现:<br>        setImmediate / MessageChannel / setTimeout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 生命周期</span><br></pre></td></tr></table></figure></p>
<p><em>init</em><br>    initLifecycle/Event，往vm上挂载各种属性<br>    callHook: beforeCreated: 实例刚创建<br>    initInjection/initState: 初始化注入和 data 响应性<br>    created: 创建完成，属性已经绑定， 但还未生成真实dom<br>    进行元素的挂载： $el / vm.$mount()<br>    是否有template: 解析成render function<br>    *.vue文件: vue-loader会将<template>编译成render function<br>    beforeMount: 模板编译/挂载之前<br>    执行render function，生成真实的dom，并替换到dom tree中<br>    mounted: 组件已挂载<br>update:<br>    执行diff算法，比对改变是否需要触发UI更新<br>    flushScheduleQueue<br>    watcher.before: 触发beforeUpdate钩子        - watcher.run(): 执行watcher中的 notify，通知所有依赖项更新UI<br>    触发updated钩子: 组件已更新<br>actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活<br>destroy:<br>    beforeDestroy: 销毁开始<br>    销毁自身且递归销毁子组件以及事件监听<br>        remove(): 删除节点<br>        watcher.teardown(): 清空依赖<br>        vm.$off(): 解绑监听<br>destroyed: 完成后触发钩子<br>上面是vue的声明周期的简单梳理，接下来我们直接以代码的形式来完成vue的初始化<br>new Vue({})<br>// 初始化Vue实例<br>function _init() {<br>     // 挂载属性<br>    initLifeCycle(vm)<br>    // 初始化事件系统，钩子函数等<br>    initEvent(vm)<br>    // 编译slot、vnode<br>    initRender(vm)<br>    // 触发钩子<br>    callHook(vm, ‘beforeCreate’)<br>    // 添加inject功能<br>    initInjection(vm)<br>    // 完成数据响应性 props/data/watch/computed/methods<br>    initState(vm)<br>    // 添加 provide 功能<br>    initProvide(vm)<br>    // 触发钩子<br>    callHook(vm, ‘created’)<br>    // 挂载节点<br>    if (vm.$options.el) {<br>        vm.$mount(vm.$options.el)<br>    }<br>}</template></p>
<p>// 挂载节点实现<br>function mountComponent(vm) {<br>     // 获取 render function<br>    if (!this.options.render) {<br>        // template to render<br>        // Vue.compile = compileToFunctions<br>        let { render } = compileToFunctions()<br>        this.options.render = render<br>    }<br>    // 触发钩子<br>    callHook(‘beforeMounte’)<br>    // 初始化观察者<br>    // render 渲染 vdom，<br>    vdom = vm.render()<br>    // update: 根据 diff 出的 patchs 挂载成真实的 dom<br>    vm._update(vdom)<br>    // 触发钩子<br>    callHook(vm, ‘mounted’)<br>}</p>
<p>// 更新节点实现<br>funtion queueWatcher(watcher) {<br>    nextTick(flushScheduleQueue)<br>}</p>
<p>// 清空队列<br>function flushScheduleQueue() {<br>     // 遍历队列中所有修改<br>    for(){<br>        // beforeUpdate<br>        watcher.before()<br>        // 依赖局部更新节点<br>        watcher.update()<br>        callHook(‘updated’)<br>    }<br>}</p>
<p>// 销毁实例实现<br>Vue.prototype.$destory = function() {<br>     // 触发钩子<br>    callHook(vm, ‘beforeDestory’)<br>    // 自身及子节点<br>    remove()<br>    // 删除依赖<br>    watcher.teardown()<br>    // 删除监听<br>    vm.$off()<br>    // 触发钩子<br>    callHook(vm, ‘destoryed’)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 数据响应(数据劫持)</span><br></pre></td></tr></table></figure></p>
<p>看完生命周期后，里面的watcher等内容其实是数据响应中的一部分。数据响应的实现由两部分构成: 观察者( watcher ) 和 依赖收集器( Dep )，其核心是 defineProperty这个方法，它可以 重写属性的 get 与 set 方法，从而完成监听数据的改变。<br>    Observe (观察者)观察 props 与 state<br>        遍历 props 与 state，对每个属性创建独立的监听器( watcher )<br>    使用 defineProperty 重写每个属性的 get/set(defineReactive）<br>        get: 收集依赖<br>        Dep.depend()<br>            watcher.addDep()<br>        set: 派发更新<br>            Dep.notify()<br>            watcher.update()<br>            queenWatcher()<br>            nextTick<br>            flushScheduleQueue<br>            watcher.run()<br>            updateComponent()<br>大家可以先看下面的数据相应的代码实现后，理解后就比较容易看懂上面的简单脉络了。<br>let data = {a: 1}<br>// 数据响应性<br>observe(data)</p>
<p>// 初始化观察者<br>new Watcher(data, ‘name’, updateComponent)<br>data.a = 2</p>
<p>// 简单表示用于数据更新后的操作<br>function updateComponent() {<br>    vm._update() // patchs<br>}</p>
<p>// 监视对象<br>function observe(obj) {<br>     // 遍历对象，使用 get/set 重新定义对象的每个属性值<br>    Object.keys(obj).map(key =&gt; {<br>        defineReactive(obj, key, obj[key])<br>    })<br>}</p>
<p>function defineReactive(obj, k, v) {<br>    // 递归子属性<br>    if (type(v) == ‘object’) observe(v)<br>    // 新建依赖收集器<br>    let dep = new Dep()<br>    // 定义get/set<br>    Object.defineProperty(obj, k, {<br>        enumerable: true,<br>        configurable: true,<br>        get: function reactiveGetter() {<br>              // 当有获取该属性时，证明依赖于该对象，因此被添加进收集器中<br>            if (Dep.target) {<br>                dep.addSub(Dep.target)<br>            }<br>            return v<br>        },<br>        // 重新设置值时，触发收集器的通知机制<br>        set: function reactiveSetter(nV) {<br>            v = nV<br>            dep.nofify()<br>        },<br>    })<br>}</p>
<p>// 依赖收集器<br>class Dep {<br>    constructor() {<br>        this.subs = []<br>    }<br>    addSub(sub) {<br>        this.subs.push(sub)<br>    }<br>    notify() {<br>        this.subs.map(sub =&gt; {<br>            sub.update()<br>        })<br>    }<br>}</p>
<p>Dep.target = null</p>
<p>// 观察者<br>class Watcher {<br>    constructor(obj, key, cb) {<br>        Dep.target = this<br>        this.cb = cb<br>        this.obj = obj<br>        this.key = key<br>        this.value = obj[key]<br>        Dep.target = null<br>    }<br>    addDep(Dep) {<br>        Dep.addSub(this)<br>    }<br>    update() {<br>        this.value = this.obj[this.key]<br>        this.cb(this.value)<br>    }<br>    before() {<br>        callHook(‘beforeUpdate’)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. virtual dom 原理实现</span><br></pre></td></tr></table></figure></p>
<p>创建 dom 树<br>树的diff，同层对比，输出patchs(listDiff/diffChildren/diffProps)<br>    没有新的节点，返回<br>    新的节点tagName与key不变， 对比props，继续递归遍历子树<br>        对比属性(对比新旧属性列表):<br>            旧属性是否存在与新属性列表中<br>            都存在的是否有变化<br>            是否出现旧列表中没有的新属性<br>    tagName和key值变化了，则直接替换成新节点<br>渲染差异<br>    遍历patchs， 把需要更改的节点取出来<br>    局部更新dom<br>// diff算法的实现<br>function diff(oldTree, newTree) {<br>     // 差异收集<br>    let pathchs = {}<br>    dfs(oldTree, newTree, 0, pathchs)<br>    return pathchs<br>}</p>
<p>function dfs(oldNode, newNode, index, pathchs) {<br>    let curPathchs = []<br>    if (newNode) {<br>        // 当新旧节点的 tagName 和 key 值完全一致时<br>        if (oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key) {<br>              // 继续比对属性差异<br>            let props = diffProps(oldNode.props, newNode.props)<br>            curPathchs.push({ type: ‘changeProps’, props })<br>            // 递归进入下一层级的比较<br>            diffChildrens(oldNode.children, newNode.children, index, pathchs)<br>        } else {<br>              // 当 tagName 或者 key 修改了后，表示已经是全新节点，无需再比<br>            curPathchs.push({ type: ‘replaceNode’, node: newNode })<br>        }<br>    }</p>
<pre><code> // 构建出整颗差异树
if (curPathchs.length) {
        if(pathchs[index]){
            pathchs[index] = pathchs[index].concat(curPathchs)
        } else {
            pathchs[index] = curPathchs
        }
}
</code></pre><p>}</p>
<p>// 属性对比实现<br>function diffProps(oldProps, newProps) {<br>    let propsPathchs = []<br>    // 遍历新旧属性列表<br>    // 查找删除项<br>    // 查找修改项<br>    // 查找新增项<br>    forin(olaProps, (k, v) =&gt; {<br>        if (!newProps.hasOwnProperty(k)) {<br>            propsPathchs.push({ type: ‘remove’, prop: k })<br>        } else {<br>            if (v !== newProps[k]) {<br>                propsPathchs.push({ type: ‘change’, prop: k , value: newProps[k] })<br>            }<br>        }<br>    })<br>    forin(newProps, (k, v) =&gt; {<br>        if (!oldProps.hasOwnProperty(k)) {<br>            propsPathchs.push({ type: ‘add’, prop: k, value: v })<br>        }<br>    })<br>    return propsPathchs<br>}</p>
<p>// 对比子级差异<br>function diffChildrens(oldChild, newChild, index, pathchs) {<br>        // 标记子级的删除/新增/移动<br>    let { change, list } = diffList(oldChild, newChild, index, pathchs)<br>    if (change.length) {<br>        if (pathchs[index]) {<br>            pathchs[index] = pathchs[index].concat(change)<br>        } else {<br>            pathchs[index] = change<br>        }<br>    }</p>
<pre><code> // 根据 key 获取原本匹配的节点，进一步递归从头开始对比
oldChild.map((item, i) =&gt; {
    let keyIndex = list.indexOf(item.key)
    if (keyIndex) {
        let node = newChild[keyIndex]
        // 进一步递归对比
        dfs(item, node, index, pathchs)
    }
})
</code></pre><p>}</p>
<p>// 列表对比，主要也是根据 key 值查找匹配项<br>// 对比出新旧列表的新增/删除/移动<br>function diffList(oldList, newList, index, pathchs) {<br>    let change = []<br>    let list = []<br>    const newKeys = getKey(newList)<br>    oldList.map(v =&gt; {<br>        if (newKeys.indexOf(v.key) &gt; -1) {<br>            list.push(v.key)<br>        } else {<br>            list.push(null)<br>        }<br>    })</p>
<pre><code>// 标记删除
for (let i = list.length - 1; i&gt;= 0; i--) {
    if (!list[i]) {
        list.splice(i, 1)
        change.push({ type: &apos;remove&apos;, index: i })
    }
}

// 标记新增和移动
newList.map((item, i) =&gt; {
    const key = item.key
    const index = list.indexOf(key)
    if (index === -1 || key == null) {
        // 新增
        change.push({ type: &apos;add&apos;, node: item, index: i })
        list.splice(i, 0, key)
    } else {
        // 移动
        if (index !== i) {
            change.push({
                type: &apos;move&apos;,
                form: index,
                to: i,
            })
            move(list, index, i)
        }
    }
})

return { change, list }
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5. Proxy 相比于 defineProperty 的优势</span><br></pre></td></tr></table></figure></p>
<p>数组变化也能监听到<br>不需要深度遍历监听</p>
<p>let data = { a: 1 }<br>let reactiveData = new Proxy(data, {<br>    get: function(target, name){<br>        // …<br>    },<br>    // …<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6. vue-router</span><br></pre></td></tr></table></figure></p>
<p>mode<br>    hash<br>    history<br>跳转<br>    this.$router.push()<br>    <router-link to=""></router-link><br>占位<br>    <router-view></router-view><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7. vuex</span><br></pre></td></tr></table></figure></p>
<p>state: 状态中心<br>mutations: 更改状态<br>actions: 异步更改状态<br>getters: 获取状态<br>modules: 将state分成多个modules，便于管理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 浏览器</span><br><span class="line">1. 跨标签页通讯</span><br></pre></td></tr></table></figure></p>
<p>不同标签页的通讯，本质原理就是运用一些可以共享的中间介质，因此比较常用的有以下方法：<br>    通过父页面window.open()和子页面postMessage<br>        异步下，通过window.open(‘about: blank’) 和 tab.location.href = ‘*’<br>    设置同域下共享的localStorage与监听window.onstorage<br>        重复写入相同的值无法触发<br>        会受到浏览器隐身模式等的限制<br>    设置共享cookie与不断轮询脏检查(setInterval)<br>    借助服务端或中间层实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 浏览器架构</span><br></pre></td></tr></table></figure></p>
<p>用户界面<br>主进程<br>内核<br>    渲染引擎<br>    js引擎<br>        执行栈<br>    事件触发线程<br>        消息队列<br>            微任务<br>            宏任务<br>    网络异步线程<br>    定时器线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 浏览器下事件循环(Event Loop)</span><br></pre></td></tr></table></figure></p>
<p>事件循环是指：执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 从输入url到展示的过程</span><br></pre></td></tr></table></figure></p>
<p>DNS解析<br>TCP三次握手<br>发送请求，分析url，设置请求报文（头，主体）<br>服务器返回请求的文件（html）<br>浏览器渲染<br>    HTML parser –&gt; DOM Tree<br>        标记化算法，进行元素状态的标记<br>    CSS parser –&gt; Style Tree<br>        结合dom树与style树<br>    layout：布局<br>    GPU painting: 像素绘制页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5. 重绘与回流</span><br></pre></td></tr></table></figure></p>
<p>当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流<br>重绘(repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少<br>回流(reflow)：当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作：<br>    页面初次渲染<br>    浏览器窗口尺寸大小改变<br>    元素尺寸、位置、内容发生改变<br>    元素字体大小改变<br>    添加或删除可见的dom元素<br>    激活css伪类(例如：:hover)<br>    查询某些属性或调用某些方法<br>        clientWidth,clientHeight,clientTop,clientLeft<br>        offsetWidth…<br>        scrollWidth…<br>        getComputedStyle()<br>        getBoundingClientRect()<br>        scrollTo()<br>回流必定触发重绘，重绘不一定触发回流。重绘的开销较少，回流的代价较高</p>
<p>最佳实践：<br>    css：<br>        避免使用table布局<br>        将动画效果应用到position属性为absolute或fixed的元素上<br>    js：<br>        避免频繁操作样式，可汇总后统一一次修改<br>        尽量使用class进行样式修改<br>        减少dom的增删次数，可使用字符串或者documentFragment一次性插入<br>        极限优化时，修改样式可将其display:none后修改<br>        避免多次触发上面提到的那些触发回流的方法，可以的话尽量用变量存住<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6. 存储</span><br></pre></td></tr></table></figure></p>
<p>我们经常需要对业务中的一些数据进行存储，通常可分为短暂性存储和持久性存储。<br>短暂性存储，我们只需要将数据存在内存中，只在运行时可用<br>持久性存储，可以分为浏览器端与服务器端<br>    浏览器：<br>        cookie：通常用于存储用户身份，登录状态等<br>        localStorage/sessionStorage：长久存储/窗口关闭删除，体积限制为4～5m<br>        indexDB<br>    服务器：<br>        分布式缓存redis<br>        数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6. 请你谈谈Cookie的弊端?</span><br></pre></td></tr></table></figure></p>
<p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。<br>    第一：每个特定的域名下最多生成20个cookie<br>    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。<br>    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。<br>    IE 提供了一种存储可以持久化用户数据，叫做uerData，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。<br>优点：极高的扩展性和可用性<br>缺点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7. Web Worker</span><br></pre></td></tr></table></figure></p>
<p>现代浏览器为JavaScript创造的 多线程环境。可以新建并将部分任务分配到worker线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。<br>基本用法:<br>    // 创建 worker<br>    const worker = new Worker(‘work.js’);</p>
<pre><code>// 向主进程推送消息
worker.postMessage(&apos;Hello World&apos;);

// 监听主进程来的消息
worker.onmessage = function (event) {
    console.log(&apos;Received message &apos; + event.data);
}
</code></pre><p>限制:<br>    同源限制<br>    无法使用 document / window / alert / confirm<br>    无法加载本地资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8. V8垃圾回收机制</span><br></pre></td></tr></table></figure>
<p>垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 新生代空间 和 老生代空间。</p>
<p>新生代空间: 用于存活较短的对象<br>    又分成两个空间: from 空间 与 to 空间<br>    Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法<br>        存活的对象从 from space 转移到 to space<br>        清空 from space<br>        from space 与 to space 互换<br>        完成一次新生代GC<br>老生代空间: 用于存活时间较长的对象<br>    从 新生代空间 转移到 老生代空间 的条件<br>        经历过一次以上 Scavenge GC 的对象<br>        当 to space 体积超过25%<br>    标记清除算法: 标记存活的对象，未被标记的则被释放<br>        增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能<br>        并发标记(最新技术): 不阻塞 js 执行<br>    压缩算法: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9. 内存泄露</span><br></pre></td></tr></table></figure>
<p>意外的全局变量: 无法被回收<br>定时器: 未被正确关闭，导致所引用的外部变量无法被释放<br>事件监听: 没有正确销毁 (低版本浏览器可能出现)<br>闭包: 会导致父级中的变量无法被释放<br>dom 引用: dom 元素被删除时，内存中的引用未被正确清空</p>
<p>可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="服务端与网络"><a href="#服务端与网络" class="headerlink" title="服务端与网络"></a>服务端与网络</h2><ol>
<li><p>http/https 协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1.0 协议缺陷:</span><br><span class="line">    无法复用链接，完成即断开，重新慢启动和 TCP 3次握手</span><br><span class="line">    head of line blocking: 线头阻塞，导致请求之间互相影响</span><br><span class="line">1.1 改进:</span><br><span class="line">    长连接(默认 keep-alive)，复用</span><br><span class="line">    host 字段指定对应的虚拟站点</span><br><span class="line">    新增功能:</span><br><span class="line">        断点续传</span><br><span class="line">        身份认证</span><br><span class="line">        状态管理</span><br><span class="line">        cache 缓存</span><br><span class="line">            Cache-Control</span><br><span class="line">            Expires</span><br><span class="line">            Last-Modified</span><br><span class="line">            Etag</span><br><span class="line">2.0:</span><br><span class="line">    多路复用</span><br><span class="line">    二进制分帧层: 应用层和传输层之间</span><br><span class="line">    首部压缩</span><br><span class="line">    服务端推送</span><br><span class="line">https: 较为安全的网络传输协议</span><br><span class="line">    证书(公钥)</span><br><span class="line">    SSL 加密</span><br><span class="line">    端口 443</span><br><span class="line">TCP:</span><br><span class="line">    三次握手</span><br><span class="line">    四次挥手</span><br><span class="line">    滑动窗口: 流量控制</span><br><span class="line">    拥塞处理</span><br><span class="line">        慢开始</span><br><span class="line">        拥塞避免</span><br><span class="line">        快速重传</span><br><span class="line">        快速恢复</span><br><span class="line">缓存策略: 可分为 强缓存 和 协商缓存</span><br><span class="line">    Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires</span><br><span class="line">    当缓存已经过期时，使用协商缓存</span><br><span class="line">        唯一标识方案: Etag(response 携带) &amp; If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，</span><br><span class="line">        最后一次修改时间: Last-Modified(response) &amp; If-Modified-Since (request，上一次返回的Last-Modified)</span><br><span class="line">            如果一致，则直接返回 304 通知浏览器使用缓存</span><br><span class="line">            如不一致，则服务端返回新的资源</span><br><span class="line">    Last-Modified 缺点：</span><br><span class="line">        周期性修改，但内容未变时，会导致缓存失效</span><br><span class="line">        最小粒度只到 s， s 以内的改动无法检测到</span><br><span class="line">    Etag 的优先级高于 Last-Modified</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见状态码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1xx: 接受，继续处理</span><br><span class="line">200: 成功，并返回数据</span><br><span class="line">201: 已创建</span><br><span class="line">202: 已接受</span><br><span class="line">203: 成为，但未授权</span><br><span class="line">204: 成功，无内容</span><br><span class="line">205: 成功，重置内容</span><br><span class="line">206: 成功，部分内容</span><br><span class="line">301: 永久移动，重定向</span><br><span class="line">302: 临时移动，可使用原有URI</span><br><span class="line">304: 资源未修改，可使用缓存</span><br><span class="line">305: 需代理访问</span><br><span class="line">400: 请求语法错误</span><br><span class="line">401: 要求身份认证</span><br><span class="line">403: 拒绝请求</span><br><span class="line">404: 资源不存在</span><br><span class="line">500: 服务器错误</span><br></pre></td></tr></table></figure>
</li>
<li><p>get / post</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get: 缓存、请求长度受限、会被历史保存记录</span><br><span class="line">    无副作用(不修改资源)，幂等(请求次数与资源无关)的场景</span><br><span class="line">post: 安全、大数据、更多编码类型</span><br><span class="line">    两者详细对比如下图:</span><br></pre></td></tr></table></figure>
</li>
<li><p>Websocket</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Websocket 是一个 持久化的协议， 基于 http ， 服务端可以 主动 push</span><br><span class="line">兼容：</span><br><span class="line">    FLASH Socket</span><br><span class="line">    长轮询： 定时发送 ajax</span><br><span class="line">    long poll： 发送 --&gt; 有消息时再 response</span><br><span class="line">new WebSocket(url)</span><br><span class="line">ws.onerror = fn</span><br><span class="line">ws.onclose = fn</span><br><span class="line">ws.onopen = fn</span><br><span class="line">ws.onmessage = fn</span><br><span class="line">ws.send()</span><br></pre></td></tr></table></figure>
</li>
<li><p>TCP三次握手</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">建立连接前，客户端和服务端需要通过握手来确认对方:</span><br><span class="line">    客户端发送 syn(同步序列编号) 请求，进入 syn_send 状态，等待确认</span><br><span class="line">    服务端接收并确认 syn 包后发送 syn+ack 包，进入 syn_recv 状态</span><br><span class="line">    客户端接收 syn+ack 包后，发送 ack 包，双方进入 established 状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>TCP四次挥手</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端 -- FIN --&gt; 服务端， FIN—WAIT</span><br><span class="line">服务端 -- ACK --&gt; 客户端， CLOSE-WAIT</span><br><span class="line">服务端 -- ACK,FIN --&gt; 客户端， LAST-ACK</span><br><span class="line">客户端 -- ACK --&gt; 服务端，CLOSED</span><br></pre></td></tr></table></figure>
</li>
<li><p>Node 的 Event Loop: 6个阶段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">timer 阶段: 执行到期的setTimeout / setInterval队列回调</span><br><span class="line">I/O 阶段: 执行上轮循环残流的callback</span><br><span class="line">idle, prepare</span><br><span class="line">poll: 等待回调</span><br><span class="line">    执行回调</span><br><span class="line">    执行定时器</span><br><span class="line">        如有到期的setTimeout / setInterval， 则返回 timer 阶段</span><br><span class="line">        如有setImmediate，则前往 check 阶段</span><br><span class="line">check</span><br><span class="line">    执行setImmediate</span><br><span class="line">close callbacks</span><br></pre></td></tr></table></figure>
</li>
<li><p>跨域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JSONP: 利用&lt;script&gt;标签不受跨域限制的特点，缺点是只能支持 get 请求</span><br><span class="line">function jsonp(url, jsonpCallback, success) &#123;</span><br><span class="line">    const script = document.createElement(&apos;script&apos;)</span><br><span class="line">    script.src = url</span><br><span class="line">    script.async = true</span><br><span class="line">    script.type = &apos;text/javascript&apos;</span><br><span class="line">    window[jsonpCallback] = function(data) &#123;</span><br><span class="line">        success &amp;&amp; success(data)</span><br><span class="line">    &#125;</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">设置 CORS: Access-Control-Allow-Origin：*</span><br><span class="line">postMessage</span><br></pre></td></tr></table></figure>
</li>
<li><p>安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XSS攻击: 注入恶意代码</span><br><span class="line">    cookie 设置 httpOnly</span><br><span class="line">    转义页面上的输入内容和输出内容</span><br><span class="line">CSRF: 跨站请求伪造，防护:</span><br><span class="line">    get 不修改数据</span><br><span class="line">    不被第三方网站访问到用户的 cookie</span><br><span class="line">    设置白名单，不被第三方网站请求</span><br><span class="line">    请求校验</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol>
<li><p>五大算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">贪心算法: 局部最优解法</span><br><span class="line">分治算法: 分成多个小模块，与原问题性质相同</span><br><span class="line">动态规划: 每个状态都是过去历史的一个总结</span><br><span class="line">回溯法: 发现原先选择不优时，退回重新选择</span><br><span class="line">分支限界法</span><br></pre></td></tr></table></figure>
</li>
<li><p>基础排序算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序: 两两比较</span><br><span class="line"></span><br><span class="line">    function bubleSort(arr) &#123;</span><br><span class="line">        var len = arr.length;</span><br><span class="line">        for (let outer = len ; outer &gt;= 2; outer--) &#123;</span><br><span class="line">            for(let inner = 0; inner &lt;=outer - 1; inner++) &#123;</span><br><span class="line">                if(arr[inner] &gt; arr[inner + 1]) &#123;</span><br><span class="line">                    [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">选择排序: 遍历自身以后的元素，最小的元素跟自己调换位置</span><br><span class="line"></span><br><span class="line">function selectSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for(let i = 0 ;i &lt; len - 1; i++) &#123;</span><br><span class="line">        for(let j = i ; j&lt;len; j++) &#123;</span><br><span class="line">            if(arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                [arr[i],arr[j]] = [arr[j],arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">插入排序: 即将元素插入到已排序好的数组中</span><br><span class="line"></span><br><span class="line">function insertSort(arr) &#123;</span><br><span class="line">    for(let i = 1; i &lt; arr.length; i++) &#123;  //外循环从1开始，默认arr[0]是有序段</span><br><span class="line">        for(let j = i; j &gt; 0; j--) &#123;  //j = i,将arr[j]依次插入有序段中</span><br><span class="line">            if(arr[j] &lt; arr[j-1]) &#123;</span><br><span class="line">                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高级排序算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">快速排序</span><br><span class="line"></span><br><span class="line">选择基准值(base)，原数组长度减一(基准值)，使用 splice</span><br><span class="line">循环原数组，小的放左边(left数组)，大的放右边(right数组);</span><br><span class="line">concat(left, base, right)</span><br><span class="line">递归继续排序 left 与 right</span><br><span class="line"></span><br><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    if(arr.length &lt;= 1) &#123;</span><br><span class="line">        return arr;  //递归出口</span><br><span class="line">    &#125;</span><br><span class="line">    var left = [],</span><br><span class="line">        right = [],</span><br><span class="line">        current = arr.splice(0,1);</span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if(arr[i] &lt; current) &#123;</span><br><span class="line">            left.push(arr[i])  //放在左边</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(arr[i]) //放在右边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return quickSort(left).concat(current,quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">希尔排序：不定步数的插入排序，插入排序</span><br><span class="line">口诀: 插冒归基稳定，快选堆希不稳定</span><br><span class="line">稳定性： 同大小情况下是否可能会被交换位置, 虚拟dom的diff，不稳定性会导致重新渲染；</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归运用(斐波那契数列)： 爬楼梯问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始在第一级，到第一级有1种方法(s(1) = 1)，到第二级也只有一种方法(s(2) = 1)， 第三级(s(3) = s(1) + s(2))</span><br><span class="line">function cStairs(n) &#123;</span><br><span class="line">    if(n === 1 || n === 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return cStairs(n-1) + cStairs(n-2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">二叉树: 最多只有两个子节点</span><br><span class="line">    完全二叉树</span><br><span class="line">    满二叉树</span><br><span class="line">        深度为 h, 有 n 个节点，且满足 n = 2^h - 1</span><br><span class="line">二叉查找树: 是一种特殊的二叉树，能有效地提高查找效率</span><br><span class="line">    小值在左，大值在右</span><br><span class="line">    节点 n 的所有左子树值小于 n，所有右子树值大于 n</span><br><span class="line">遍历节点</span><br><span class="line">    前序遍历</span><br><span class="line">        根节点</span><br><span class="line">        访问左子节点，回到 1</span><br><span class="line">        访问右子节点，回到 1</span><br><span class="line">    中序遍历</span><br><span class="line">        先访问到最左的子节点</span><br><span class="line">        访问该节点的父节点</span><br><span class="line">        访问该父节点的右子节点， 回到 1</span><br><span class="line">    后序遍历</span><br><span class="line">        先访问到最左的子节点</span><br><span class="line">        访问相邻的右节点</span><br><span class="line">        访问父节点， 回到 1</span><br><span class="line">插入与删除节点</span><br></pre></td></tr></table></figure>
</li>
<li><p>天平找次品</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有n个硬币，其中1个为假币，假币重量较轻，你有一把天平，请问，至少需要称多少次能保证一定找到假币?</span><br><span class="line">三等分算法:</span><br><span class="line">    将硬币分成3组，随便取其中两组天平称量</span><br><span class="line">        平衡，假币在未上称的一组，取其回到 1 继续循环</span><br><span class="line">        不平衡，假币在天平上较轻的一组， 取其回到 1 继续循环</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/pay-weixin.jpg" alt="steven.wang 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/pay-zhifubao.jpg" alt="steven.wang 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/前端-面试/" rel="tag"># 前端,面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/tools/开始我的博客/" rel="next" title="开始我的博客">
                <i class="fa fa-chevron-left"></i> 开始我的博客
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/client/javascript/js_topic_01/" rel="prev" title="JS 学习笔记">
                JS 学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars2.githubusercontent.com/u/4902693"
                alt="steven.wang" />
            
              <p class="site-author-name" itemprop="name">steven.wang</p>
              <p class="site-description motion-element" itemprop="description">我是一名前端工程师，专注学习各种编程语言</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/StevenStar" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、HTML-面试问题及答案"><span class="nav-number">1.</span> <span class="nav-text">一、HTML 面试问题及答案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML-基础"><span class="nav-number">1.1.</span> <span class="nav-text">HTML 基础</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、CSS-面试问题及答案"><span class="nav-number">2.</span> <span class="nav-text">二、CSS 面试问题及答案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS-基础"><span class="nav-number">2.1.</span> <span class="nav-text">CSS 基础</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、JAVASCRIPT-面试问题及答案"><span class="nav-number">3.</span> <span class="nav-text">三、JAVASCRIPT 面试问题及答案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-基础"><span class="nav-number">3.1.</span> <span class="nav-text">JS 基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务端与网络"><span class="nav-number">3.2.</span> <span class="nav-text">服务端与网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法"><span class="nav-number">3.3.</span> <span class="nav-text">算法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://stevenstar.github.io/web/web_topic_01/';
        this.page.identifier = 'web/web_topic_01/';
        this.page.title = '前端面试集锦';
      };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
